[[appendix-examples-groups, Appendix I, Good Practices and Annotated Examples for Using Groups]]

[appendix]
== Good Practices and Annotated Examples for Using Groups

This appendix contains good practices for using netCDF-4 groups in CF compliant data, as well as annotated examples of existing use cases for representing data using groups.

=== Good practices

. The use of attributes attached to a group in order to store metadata normally attached directly to variables is discouraged.
This includes, for example, replacing per-variable attributes like `_FillValue`, `scale_factor`, `valid_min`, with group-level equivalents.
Although group attributes might be more concise, it is likely to create problems with downstream software and reduce interoperability.

. Each group's attributes, dimensions and variables should be self-contained in combination with the group metadata and any inherited properties (e.g., dimension sizes, coordinates).
This ensures that if a group is renamed or extracted (with any inherited properties) into a new file, its information content is preserved.
For example, storage of ensembles as sibling groups (as described below) is often clearer when the realization number is encoded in the group name.
In this case, the `Realization` group attribute retains the realization number even if the group is renamed.
Other commonly enumerated group names, such as station identifiers, buoy numbers, or channel wavelengths are analogous.
It is fine to enumerate or itemize names so long as the number or name is redundantly stored as a group attribute.

. Renaming or moving a group or self-contained branch of groups to a new location should not affect the interpretation of data.
Since relative and absolute paths (containing "/") of coordinates, dimensions, and attributes are fragile, it is preferred they not be present in attributes.
Instead, named objects resolve to the most proximal object (i.e., dimension or variable) of that name that has the referring attribute within its scope.
This makes files which use groups amenable to sub-setting and aggregation.
For example, the CF `coordinates` attribute identifies a variable's coordinates in a whitespace-separated list such as `"lat lon"`.
When the coordinates are outside the group that contains the `coordinates` attribute, it is tempting to store the coordinate locations as full, unambiguous paths such as `"/g1/lat /g1/lon"`, or as relative paths such as `"g1/lat g1/lon"`.
However, paths that contain slashes must be explicitly altered when the variable is subset into a new file with a different group hierarchy, or when the hierarchy is flattened.
CF attributes affected by this practice include `ancillary_variables`, `bounds`, `cell_measures`, `climatology`,  `coordinates`, `formula_terms`, and `grid_mapping`.
The simpler `"lat lon"` specification works without alteration in all situations for out-of-group locations so long as it is understood to mean the nearest identifiers that have the referring variable in their scope.

. When using a grid mapping which is referenced in multiple groups, the reference to the coordinates themselves should be maintained as an attribute of the referencing variables, and not as an attribute of the grid mapping itself. This way the coordinates can resolve to the correct coordinates which are "owned" by the referencing variable, and which are not shared amongst variables, while the grid mapping which is used to interpret the coordinates is stored in only one place. Both coordinates and grid mapping are thus found via regular scoping mechanisms.
+
A common use case for this is data produced on board a geostationary platform. Different swaths are stored in different groups, each with their own coordinates, but all of which share a common grid mapping for the entire full disk view.

=== Use cases

==== Collections

Group datasets are well-suited when users might benefit from storing related datasets (collections of variables) in a single location (file).
Loose collections might comprise different sets of distinct variables with a common purpose, e.g., multiple sensor observations at a single location.
For example, a model and satellite retrieval of a temperature field might be combined with an in situ temperature sensor as follows:

[[example-i.1]]
[caption="Example I.1. "]
.Collection of related datasets sharing a single set of global metadata and segregated using groups.
====
----
netcdf clc {
  :Conventions = "CF-1.8";
  :history = "Tue Apr 25 12:46:10 PDT 2017: ncgen -k netCDF-4 -b -o ~/nco/data/clc.nc ~/nco/data/clc.cdl";
  :Purpose = "Demonstrate a collection of related datasets stored in hierarchical format";

  group: model {
    :Source = "Model simulations, e.g., of temperature";
    dimensions:
      lat=2;
      lon=3;
      time=unlimited;
    variables:
      float temperature(time,lat,lon);
      double time(time); // Variable attributes omitted for clarity
      double lat(lat);
      double lon(lon);
      data:
      lat=-90,90.;
      lon=0.,120.,240.;
      temperature=273.,273.,273.,273.,273.,273.;
      time=1.;
  } // end model

  group: measurements_remote_sensing {
    :Source = "Satellite measurements of same region as modelled, and on a different spatio-temporal grid";
    dimensions:
      lat=3;
      lon=4;
      time=unlimited;
    variables:
      float temperature(time,lat,lon);
      double time(time); // Variable attributes omitted for clarity
      double lat(lat);
      double lon(lon);
      data:
      lat=-90,0.,90.;
      lon=0.,90.,180.,270.;
      temperature=273.,273.,273.,273.,273.,273.,273.,273.,273.,273.,273.,273.;
      time=1.;
  } // end measurements_remote_sensing

  group: measurements_in_situ {
    :Source = "In situ measurements, e.g., from an automated weather station with its own time-frequency";
    dimensions:
      time=unlimited;
    variables:
      float temperature_10m(time);
      double time(time); // Variable attributes omitted for clarity
      data:
      temperature_10m=271,272,273,274;
      time=1.,2.,3.,4.;
  } // end measurements_in_situ
} // end root group
----
The namespace separation provided by groups allows variable and dimension names to be re-used and axes lengths to be re-defined.
In this example two groups contain a `temperature` variable, and the third contains a temperature at 10 m height.
Each group has its own spatio-temporal grid that re-uses the same coordinate names (`lat`, `lon`, `time`) as the other groups without conflict.
====

==== Ensembles

Geoscientists use the label "ensemble" for collections of realizations of individual models or measurements of the same phenomena.
It is particularly important for models to repeat simulations of nonlinear systems multiple times (with slightly perturbed initial conditions) in order to characterize the statistical properties of systems with internal variability.
The namespace separation provided by groups ensures that variable names can be re-used.
Axis lengths can be re-defined if distinct realizations employ different spatio-temporal resolutions.
Multiple realizations of a single model temperature field might be stored as:

[[example-i.2]]
[caption="Example I.2. "]
.Various members of an ensemble forecast stored as individual groups.
====
----
netcdf nsm {
  :Conventions = "CF-1.8";
  :history = "Tue Apr 25 12:46:10 PDT 2017: ncgen -k netCDF-4 -b -o ~/nco/data/clc.nc ~/nco/data/clc.cdl";
  :Purpose = "Demonstrate a model ensemble stored in hierarchical format";

  group: cesm_01 {
    :Scenario = "Historical";
    :Model = "CESM";
    :Realization = "1";

    dimensions:
      time=unlimited;
    variables:
      float temperature(time);
      double time(time);
    data:
      temperature=272.1,272.1,272.1,272.1;
      time=1.,2.,3.,4.;
    } // cesm_01

  group: cesm_02 {
    :Scenario = "Historical";
    :Model = "CESM";
    :Realization = "2";

    dimensions:
      time=unlimited;
    variables:
      float temperature(time);
      double time(time);
    data:
      temperature=272.2,272.2,272.2,272.2;
      time=1.,2.,3.,4.;
    } // cesm_02

  group: cesm_03 {
    :Scenario = "Historical";
    :Model = "CESM";
    :Realization = "3";

    dimensions:
      time=unlimited;
    variables:
      float temperature(time);
      double time(time);
    data:
      temperature=272.3,272.3,272.3,272.3;
      time=1.,2.,3.,4.;
    } // cesm_03
} // root group
----
Here each group contains a different realization of the same model, and the group names are suffixed with a numerical identifier, as well as containing a numerically valued group attribute named `Realization`.
This attribute would be carried with its group should the group ever be renamed or extracted into a new file, thus preserving the identity of the original realization.
It is allowed to include numeric metadata in group names so long as the information is redundantly stored as group metadata (e.g., `Realization`).
To accommodate the potential need of downstream software to deconstruct a number-containing group name into its original components it is suggested that the numeric portion be encoded as a fixed-width string separated by a non-alphanumeric character, such as "`_03`" above.
====

==== Discrete Sampling Geometries

CF describes a powerful syntax for encoding spatiotemporal data from multiple locations into multidimensional flat-file formats.
The patterns of the spatiotemporal data are encapsulated into several features, each labeled with a distinct `featureType` that must be either `point`, `timeSeries`, `profile`, `trajectory`, `timeSeriesProfile`, or `trajectoryProfile`.
These features use an instance dimension to span a collection of like features.
One-dimensional variables that have only the instance dimension in a Discrete Geometry CF file are called instance variables.
Common instance variables include `lat(station)` and `station_name(station, name_len)`.
Here the `station` dimension enumerates the stations in the collection.

It is also possible to use groups as an extended form of discrete sampling features where groups replace the instance dimension in Discrete Sampling Geometries.
Instead of a `station` dimension, feature collections may designate a group to contain the feature for each station.
Typically the group name would be the same as the `station_name`.
A `timeSeries` collection might appear like this:

[[example-i.3]]
[caption="Example I.3. "]
.Orthogonal time series stored using groups.
====
----
netcdf tms {
  :Conventions = "CF-1.8";
  :history = "Thu Jun 22 17:45:12 PDT 2017: ncgen -k netCDF-4 -b -o ~/nco/data/tms.nc ~/nco/data/tms.cdl";
  :Purpose = "Demonstrate a collection of DSG timeSeries featureType stored in hierarchical format";
  :featureType = "timeSeries";

  dimensions:
    time=unlimited;

  variables:
    double time(time) ;
    time:standard_name = "time";
    time:long_name = "time of measurement" ;
    time:units = "days since 1970-01-01 00:00:00" ;

  group: irvine {
    variables:

      float humidity(time) ;
        humidity:standard_name = "specific humidity" ;
        humidity:coordinates = "lat lon alt station_name" ;
        humidity:_FillValue = -999.9f;

      float lon ;
        lon:standard_name = "longitude";
        lon:long_name = "station longitude";
        lon:units = "degrees_east";

      float lat ;
        lat:standard_name = "latitude";
        lat:long_name = "station latitude" ;
        lat:units = "degrees_north" ;

      float alt ;
        alt:long_name = "vertical distance above the surface" ;
        alt:standard_name = "height" ;
        alt:units = "m";
        alt:positive = "up";
        alt:axis = "Z";

      string station_name;
        station_name:long_name = "station name" ;
        station_name:cf_role = "timeseries_id";
  } // irvine

 group: boulder {
    // Variables/dimensions repeated, omitted for clarity
  } // boulder
} // root group
----
Placement of the `time` dimension depends upon the characteristics of the sensor network, and is key to economically represent the collection.
If sensors at different locations measure values at the same time, then a single `time` coordinate may be placed in the root directory.
Each station (group) inherits this coordinate.
This is the case for an orthogonal multidimensional array representations.
====

When stations measure with distinct time coordinates amongst themselves, it is recommended that the `time` coordinates be stored locally within each group:

[[example-i.4]]
[caption="Example I.4. "]
.Ragged array of station time series stored using groups.
====
----
netcdf tms {

  // Global metadata omitted for clarity

  group: irvine {
  dimensions:
    time=unlimited;
  variables:
    double time(time) ;
      time:standard_name = "time";
      time:long_name = "time of measurement" ;
      time:units = "days since 1970-01-01 00:00:00" ;
    // Variables besides time as before, omitted for clarity
  } // irvine

 group: boulder {
    dimensions:
      time=unlimited;

  variables:
    double time(time) ;
      time:standard_name = "time";
      time:long_name = "time of measurement" ;
      time:units = "days since 1970-01-01 00:00:00" ;
    // Variables besides time as before, omitted for clarity
  } // boulder
} // root group
----
This accommodates the common situation where different sensors have different observation times.
An alternative approach the use of an incomplete multidimensional array representation, which increases the rank and size of the `time` coordinate, so that each station must allocate space for all observation times used anywhere in the collection.
Groups can avoid this complexity by employing a station-specific `time` coordinate within each group.
This saves space relative to the incomplete multidimensional array representation since the representation using groups avoids padding the missing data.

This formalism of station-specific `time` coordinates also naturally handles timeseries with time-varying deviations from a nominal point spatial location and offers an alternative to contiguous and indexed ragged arrays.
====

==== Remote sensing channels

In satellite remote sensing, hierarchical datasets can be useful for storing low-level data, such as payload data, engineering data or instrument data for processing into geophysical variables.
While it is useful to store all sensed data from a single satellite or instrument in one unified file, many applications require only a subset of this data in order to produce higher-level products.
Additionally, some applications require data concerning the state of the vehicle or instrument, while others do not.
Therefore it is useful to split the observations from different channels and/or instruments into different groups within the netCDF file, as follows (for the sake of simplicity, a reduced, hypothetical file is shown):

[[example-i.5]]
[caption="Example I.5. "]
.Rich remote sensing data represented hierarchically using groups.
====
----
netcdf nextgen-satellite {
  // global attributes:
  :title = "EUMETSAT EPS-SG IASI-NG Level 1c data" ;
  :summary = "Demonstrate a Level 1 satellite product stored using groups";
  :Conventions = "CF-1.8";
  :orbit_start = 5 ;
  :orbit_end = 6 ;

  group: status {
    group: satellite {
      dimensions:
            manoeuvre_items = 0 ;
      variables:
            int manoeuvre_start_time_utc(manoeuvre_items);
            int manoeuvre_end_time_utc(manoeuvre_items);
    } // group satellite
  } // group status

  group: data {
    group: instrument_01 {
      :instrument_identifier = "IASI-NG" ;

      dimensions: time = 1 ;
      dimensions: nrows = 1 ;
      dimensions: ncols = 1 ;

      variables:
        float lat(nrows, ncols) ;
          lat:units = "degrees_north" ;
          lat:standard_name = "latitude" ;
        float lon(nrows, ncols) ;
          lon:units = "degrees_east" ;
          lon:standard_name = "longitude" ;
        double time(time) ;
          time:standard_name = "time" ;
          time:units = "seconds since 2000-01-01 00:00.00Z" ;
          time:calendar = "gregorian" ;

      group: band_01 {
        :sensor_band_identifier = "IASI-NG Channel 1" ;

        group: radiances {
          dimensions:
            n_wavenumbers = 1 ;

          variables:
            int wavenumber(n_wavenumbers) ;
              wavenumber:standard_name = "sensor_band_central_radiation_wavenumber" ;
            double spectrum(nrows, ncols, n_wn) ;
              spectrum:standard_name = "toa_outgoing_radiance_per_unit_wavenumber" ;
        } // group radiances

        group: quality {
          variables:
            int number_of_missing_samples(nrows, ncols) ;
          } // group quality

        } // group band_01

      group: band_02{
        :sensor_band_identifier = "IASI-NG Channel 2" ;
      } // group band_02
    } // group instrument_01

    group: instrument_02 {
      :instrument_identifier = "IASI-TLA" ;
    } // group instrument_02
  } // group data
----
A real example would be much more complex, but already this contrived example demonstrates the flexibility gained through the use of groups.
In this case, all observations from a given orbital dump are stored in a single file.
Subsets of this file can easily be produced, however, which contain observations only from certain instruments or certain bands of various instruments.
This can greatly reduce the volume of data which must be transferred between production facilities and thus increase timeliness for near-real-time products without sacrificing metadata integrity for archival purposes.
====

=== Mapping between Hierarchical and Flat files

Files which use groups can be mapped to a set of flat files.
This procedure involves separating the group hierarchy tree into multiple distinct, self-contained, flat files, and is called _dismembering_.
A related procedure, _flattening_, collapses an entire hierarchical file into a single flat file.

Files constructed in accord with the best practices outlined in this document can be dismembered without loss of information.
This allows dismembered files to be used with software aware of only flat files.
However, dismemberment often destroys the logical associations between data embodied in the original hierarchical file.

Files using groups can be flattened without loss or alteration of information only in cases where none of the groups or their contents re-use name identifiers.
When name identifiers are re-used, a flattening algorithm must disambiguate the namespace conflicts in the flattened file, and this results in metadata alteration.
To guarantee resolution of such namespace conflicts, the flattening procedure must rename conflicting variables, dimensions, and group attributes.
For example, variables that share a name in separate groups in a hierarchical file (e.g., `/g1/v1` and `/g2/v1`) can be renamed by concatenating their names with their original group paths, with forward-slash path separators eliminated or replaced by a special character string in the flattened version (e.g., `g1_v1` and `g2_v1`).
A similar procedure must be followed to resolve namespace conflicts for group metadata and for dimension names.

The link:$$https://www.opendap.org/software/hyrax-data-server$$[OPeNDAP Hyrax Data Server] implements such an algorithm when flattening hierarchical files.
Hyrax goes further in that it renames all variables beneath the root group by prepending the former full path name (with slashes represented as spaces) to the original short name.
Hyrax preserves the original name and group path of the variables in new attributes named `origname` and `fullnamepath`.
Their preservation ensures that a suitably programmed "inflation" tool could reverse the flattening and re-construct a hierarchical file with all the original names.
To our knowledge, no such inflator is yet available.
Software to flatten hierarchical files without namespace conflicts is available (e.g., link:$$http://nco.sf.net/nco.html#flatten$$[NCO]).
It is anticipated that tools (such as flatteners and inflators) that facilitate interoperability of files using groups will become more mature in the future.
